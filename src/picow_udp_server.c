/*********************************************************************
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE. 
* 
* UDP Server                                			    	     *
*                                                                    *
* Version: 1.0                                                       *
* Date:    08-02-2025                                                *
* Author:  Dan Machado                                               *
*                                                                    *
* Based on TCP server pico w example                                 *
**********************************************************************/
#include "udp_server/picow_udp_server.h"
#include "udp_server/server_config.h" // Generated by cmake

#include <string.h>
#include <stdlib.h>

#include "pico/cyw43_arch.h"
#include "lwip/pbuf.h"
#include "lwip/udp.h"

//-------------------------------------------------------------------

void stunt_callback(const uint8_t* b, const uint16_t s)
{
	(void) b;
	(void) s;
}

//-------------------------------------------------------------------

typedef struct UDP_SERVER_T_ 
{
	uint8_t buffer_recv[BUF_SIZE];
	struct udp_pcb* server_pcb;
	ip_addr_t* client_addr;
	int recv_data_size;
	uint16_t client_port;
	bool running;
	void (*RECV_CBK)(const uint8_t*, const uint16_t);
} UDP_SERVER_T;

static UDP_SERVER_T* udp_server=NULL;

//-------------------------------------------------------------------

static bool server_init()
{
	udp_server = calloc(1, sizeof(UDP_SERVER_T));

	if (!udp_server) {
		usb_dbg("failed to allocate tcp_server\n");
		return false;
	}

	udp_server->recv_data_size=0;
	udp_server->running=true;
	ip_addr_t* addr=calloc(1, sizeof(ip_addr_t));
	udp_server->client_addr=addr;
	udp_server->client_port=0;
	udp_server->RECV_CBK=stunt_callback;
	return true;
}

//-------------------------------------------------------------------

static void server_close() 
{
	if (udp_server->client_addr != NULL) {
		udp_recv(udp_server->server_pcb, NULL, NULL);
		free(udp_server->client_addr);
		udp_server->client_addr = NULL;
	}

	if (udp_server->server_pcb) {
		udp_remove(udp_server->server_pcb);
		//udp_disconnect(udp_server->server_pcb);
		udp_server->server_pcb = NULL;
	}

	free(udp_server);

	udp_server=NULL;
}

//-------------------------------------------------------------------

/*
Read documentation: https://www.nongnu.org/lwip/2_0_x/udp_8h.html#af0ec7feb31acdb6e11b928f438c8a64b
*/

static void receive_from(void* arg, struct udp_pcb* pcb, struct pbuf* p, const ip_addr_t* addr, u16_t port)
{	
	(void) pcb;
	(void) arg;

	if(p->tot_len>0){
		if(ip_addr_cmp((udp_server->client_addr), addr)==0){
			ip_addr_copy((*udp_server->client_addr), *addr);
		}

		if(udp_server->client_port!=port){	
			udp_server->client_port=port;
		}

		udp_server->recv_data_size = pbuf_copy_partial(p, udp_server->buffer_recv,
											 p->tot_len > BUF_SIZE ? BUF_SIZE : p->tot_len, 0);

		udp_server->RECV_CBK(udp_server->buffer_recv, udp_server->recv_data_size);
	}
	pbuf_free(p);
}

//-------------------------------------------------------------------

static bool open_udp_server(UDP_SERVER_T* server) 
{
	if(NULL==server){
		return false;	
	}

	usb_dbg("Starting server at %s on port %u\n", ip4addr_ntoa(netif_ip4_addr(netif_list)), UDP_PORT);

	struct udp_pcb* pcb = udp_new();
	if (!pcb) {
		usb_dbg("failed to create pcb\n");
		return false;
	}

	err_t err = udp_bind(pcb, IP_ADDR_ANY, UDP_PORT);
	if (err) {
		usb_dbg("failed to bind to port %d\n", UDP_PORT);
		server_close();
		return false;
	}

	server->server_pcb=pcb;

	udp_recv(pcb, receive_from, NULL);	

	return true;
}

//-------------------------------------------------------------------

bool send_data(const void* buffer, const uint16_t bfs)
{
	u16_t buffer_size=(u16_t)bfs;
	struct pbuf* dataBuffer=pbuf_alloc(PBUF_TRANSPORT, buffer_size, PBUF_RAM);

	pbuf_take(dataBuffer, buffer, buffer_size);

	err_t er = udp_sendto(udp_server->server_pcb, dataBuffer, 
		(const ip_addr_t*) udp_server->client_addr, udp_server->client_port);

	pbuf_free(dataBuffer);
	return er==ERR_OK;
}

//-------------------------------------------------------------------

bool start_udp_server(void (*RECV_CBK)(const uint8_t*, const uint16_t)) 
{
	if (!server_init()) {
		return false;
	}

	if (!open_udp_server(udp_server)) {
		return false;
	}

	udp_server->RECV_CBK=RECV_CBK;

	return udp_server->running;
}

//-------------------------------------------------------------------

void server_poll()
{
	#if PICO_CYW43_ARCH_POLL
	cyw43_arch_poll();
	#endif
}

//-------------------------------------------------------------------

bool init_network()
{
    if (cyw43_arch_init()) {
        usb_dbg("failed to initialise\n");
        return false;
    }

    cyw43_arch_enable_sta_mode();

    usb_dbg("Connecting to Wi-Fi...\n");
    if (cyw43_arch_wifi_connect_timeout_ms(WIFI_SSID, WIFI_PASSWORD, CYW43_AUTH_WPA2_AES_PSK, 30000)) {
       usb_dbg("failed to connect.\n");
        return false;
    } else {
        usb_dbg("Connected.\n");
    }
    
    return true;
}

//-------------------------------------------------------------------

void send_ok()
{
	uint8_t ok=0x01;
	send_data(&ok, 1);
}

//-------------------------------------------------------------------

void handshake()
{
	uint8_t ok=0x10;
	send_data(&ok, 1);
}

//-------------------------------------------------------------------

void stop_network()
{
	if(udp_server!=NULL){
		server_close();
	}
	cyw43_arch_deinit();
}

//===================================================================
